"""
Client-side workflow manager.

Handles workflow retrieval and coordination with WorkflowEngine.
Workflow generation happens in the user's google_adk flow, not here.
"""

import logging
from typing import Any, List, Optional

from ryumem.core.workflow_models import WorkflowDefinition
from ryumem.workflows.engine import WorkflowEngine

logger = logging.getLogger(__name__)


class WorkflowManager:
    """
    Client-side workflow manager.

    Responsibilities:
    - Search for existing workflows
    - Coordinate with WorkflowEngine for execution
    - Save workflows generated by google_adk
    """

    def __init__(self, ryumem_client: Any):
        """
        Initialize workflow manager.

        Args:
            ryumem_client: Ryumem SDK instance

        Raises:
            ValueError: If workflow mode is not enabled
        """
        self.ryumem = ryumem_client
        self.engine = WorkflowEngine(ryumem_client)

        # Check if workflow mode is enabled
        if not self.ryumem.config.workflow.workflow_mode_enabled:
            raise ValueError(
                "Workflow mode not enabled. Set RYUMEM_WORKFLOW_MODE_ENABLED=true"
            )

    def search_workflow(
        self, query: str, user_id: str
    ) -> Optional[WorkflowDefinition]:
        """
        Search for existing workflow matching the query.

        Args:
            query: User query
            user_id: User ID

        Returns:
            WorkflowDefinition if found, None if not found
        """
        threshold = self.ryumem.config.workflow.similarity_threshold

        logger.info(f"Searching for similar workflows for query: {query[:50]}...")
        similar_workflows = self.ryumem.search_workflows(
            query=query,
            user_id=user_id,
            threshold=threshold,
        )

        if similar_workflows:
            # Found similar workflow - reuse it
            workflow_dict = similar_workflows[0]
            workflow = WorkflowDefinition(**workflow_dict)
            logger.info(
                f"Found similar workflow: {workflow.name} (ID: {workflow.workflow_id})"
            )
            return workflow

        logger.info("No similar workflow found")
        return None

    def validate_workflow(self, workflow: WorkflowDefinition) -> tuple[bool, list[str]]:
        """
        Validate workflow structure and connectivity.

        Args:
            workflow: WorkflowDefinition to validate

        Returns:
            Tuple of (is_valid, errors) where errors is list of error messages
        """
        errors = []
        from ryumem.core.workflow_models import NodeType

        # Check workflow has nodes
        if not workflow.nodes:
            errors.append("Workflow must have at least one node")
            return False, errors

        # Check node_ids are unique
        node_ids = [n.node_id for n in workflow.nodes]
        if len(node_ids) != len(set(node_ids)):
            duplicates = [nid for nid in node_ids if node_ids.count(nid) > 1]
            errors.append(f"Duplicate node_ids found: {set(duplicates)}")

        # Check dependencies reference valid nodes
        for node in workflow.nodes:
            for dep in node.dependencies:
                if dep not in node_ids:
                    errors.append(f"Node '{node.node_id}': dependency '{dep}' does not exist")

        # Check tool nodes have required fields
        for node in workflow.nodes:
            if node.node_type == NodeType.TOOL:
                if not node.tool_name:
                    errors.append(f"Node '{node.node_id}': tool_name is required for tool nodes")
                if not node.input_params:
                    errors.append(f"Node '{node.node_id}': input_params is required for tool nodes")

        # Check for disconnected nodes
        # Find root nodes (no dependencies)
        root_nodes = [n.node_id for n in workflow.nodes if not n.dependencies]
        if not root_nodes:
            errors.append("No root nodes found (circular dependency or all nodes have dependencies)")
            return False, errors

        # Check all nodes are reachable from root nodes via dependency chain
        # We traverse forward: from root nodes, follow the nodes that depend on them
        reachable = set()
        node_map = {n.node_id: n for n in workflow.nodes}

        def mark_reachable(node_id):
            if node_id in reachable or node_id not in node_map:
                return
            reachable.add(node_id)
            # Find nodes that depend on this node (nodes that list this node in their dependencies)
            for node in workflow.nodes:
                if node_id in node.dependencies:
                    mark_reachable(node.node_id)

        # Start from all root nodes
        for root in root_nodes:
            mark_reachable(root)

        # Check if all nodes were reached
        unreachable = set(node_ids) - reachable
        if unreachable:
            unreachable_details = [f"{nid} (depends on: {node_map[nid].dependencies or 'none'})" for nid in unreachable]
            errors.append(f"Disconnected nodes found - not reachable from any root node: {', '.join(unreachable_details)}")

        return len(errors) == 0, errors

    def save_workflow(self, workflow: WorkflowDefinition) -> str:
        """
        Save a workflow generated by google_adk.

        Args:
            workflow: WorkflowDefinition to save

        Returns:
            Workflow ID

        Raises:
            ValueError: If workflow is invalid
        """
        # Validate workflow before saving
        is_valid, errors = self.validate_workflow(workflow)
        if not is_valid:
            error_msg = "Workflow validation failed: " + "; ".join(errors)
            logger.error(f"âŒ {error_msg}")
            raise ValueError(error_msg)

        result = self.ryumem.create_workflow(workflow.model_dump(mode='json'))
        workflow_id = result.get("workflow_id")
        logger.info(f"Saved workflow to server: {workflow_id}")
        return workflow_id

    def get_workflow(self, workflow_id: str) -> Optional[WorkflowDefinition]:
        """
        Get a specific workflow by ID.

        Args:
            workflow_id: Workflow ID

        Returns:
            WorkflowDefinition if found, None otherwise
        """
        workflow_dict = self.ryumem.get_workflow(workflow_id)
        if workflow_dict:
            return WorkflowDefinition(**workflow_dict)
        return None

    def list_workflows(
        self, user_id: Optional[str] = None, limit: int = 100
    ) -> List[WorkflowDefinition]:
        """
        List workflows.

        Args:
            user_id: Filter by user ID (optional)
            limit: Maximum number of workflows to return

        Returns:
            List of WorkflowDefinitions
        """
        workflow_dicts = self.ryumem.list_workflows(user_id=user_id, limit=limit)
        return [WorkflowDefinition(**w) for w in workflow_dicts]

    def _pause_workflow(
        self,
        workflow_id: str,
        session_id: str,
        user_id: str,
        node_id: str,
        pause_reason: str,
        prompt: str = None,
        error: str = None,
        extra_fields: dict = None
    ) -> dict[str, Any]:
        """Helper to pause workflow and return status."""
        self.engine.set_paused(
            session_id=session_id,
            user_id=user_id,
            paused_at_node=node_id,
            pause_reason=pause_reason,
            prompt=prompt,
            error_details=error
        )

        result = {
            "workflow_id": workflow_id,
            "session_id": session_id,
            "status": "paused",
            "pause_reason": pause_reason,
            "paused_at_node": node_id,
        }

        if prompt:
            result["prompt"] = prompt
        if error:
            result["error"] = error
        if extra_fields:
            result.update(extra_fields)

        return result

    def _substitute_variables(self, template: str, context: dict) -> str:
        """Replace ${variable} or $[variable] references in template."""
        for var_name, var_value in context.items():
            # Support both common syntaxes
            template = template.replace(f"${{{var_name}}}", str(var_value))
            template = template.replace(f"$[{var_name}]", str(var_value))
        return template

    def _execute_node(
        self,
        node,
        context: dict[str, Any],
        tool_registry: Optional[dict] = None
    ) -> dict[str, Any]:
        """Execute a single workflow node."""
        from datetime import datetime
        import time

        start_time = time.perf_counter()

        try:
            # Get the tool function from registry
            if not tool_registry or not node.tool_name:
                raise ValueError(f"Tool registry or tool_name not provided for node {node.node_id}")

            if node.tool_name not in tool_registry:
                raise ValueError(f"Tool '{node.tool_name}' not found in tool registry")

            tool_func = tool_registry[node.tool_name]

            # Substitute variables in input_params
            substituted_params = {}
            if node.input_params:
                for key, value in node.input_params.items():
                    if isinstance(value, str):
                        substituted_params[key] = self._substitute_variables(value, context)
                    else:
                        substituted_params[key] = value

            # Execute the tool
            output = tool_func(**substituted_params)

            duration_ms = int((time.perf_counter() - start_time) * 1000)

            return {
                "node_id": node.node_id,
                "node_type": str(node.node_type),
                "status": "completed",
                "output": output,
                "error": None,
                "duration_ms": max(1, duration_ms),
                "timestamp": datetime.utcnow().isoformat()
            }
        except Exception as e:
            duration_ms = int((time.perf_counter() - start_time) * 1000)
            logger.error(f"Error executing node {node.node_id}: {e}")
            return {
                "node_id": node.node_id,
                "node_type": str(node.node_type),
                "status": "failed",
                "output": None,
                "error": str(e),
                "duration_ms": max(1, duration_ms),
                "timestamp": datetime.utcnow().isoformat()
            }

    def execute_workflow(
        self,
        workflow_id: str,
        session_id: str,
        user_id: str,
        initial_variables: dict[str, Any],
        tool_registry: Optional[dict[str, Any]] = None
    ) -> dict[str, Any]:
        """
        Execute a workflow client-side.

        Args:
            workflow_id: Workflow ID to execute
            session_id: Session ID for tracking execution
            user_id: User ID for session tracking
            initial_variables: Initial variables for workflow context
            tool_registry: Optional dictionary mapping tool names to callable functions

        Returns:
            Execution result with status and node outputs

        Raises:
            ValueError: If workflow not found or different workflow is paused
        """
        logger.info(f"ðŸš€ Starting workflow execution: workflow_id={workflow_id}, session_id={session_id}, user_id={user_id}")
        logger.info(f"   Initial variables: {list(initial_variables.keys())}")

        # Check if session already has paused workflow
        session = self.ryumem.get_session(session_id)
        if session and session.get("status") == "paused":
            pause_info = self.engine.get_pause_info(session_id, user_id)
            if session.get("workflow_id") != workflow_id:
                raise ValueError(
                    f"Session has paused workflow {session.get('workflow_id')}, "
                    f"cannot start {workflow_id}"
                )
            pause_reason = pause_info.get("pause_reason") if pause_info else "unknown"
            logger.info(f"â™»ï¸  Auto-resuming paused workflow, reason: {pause_reason}")
            self.engine.clear_pause(session_id, user_id)

        # Get workflow definition
        workflow = self.get_workflow(workflow_id)
        if not workflow:
            logger.error(f"âŒ Workflow {workflow_id} not found")
            raise ValueError(f"Workflow {workflow_id} not found")

        logger.info(f"âœ“ Loaded workflow: {workflow.name} with {len(workflow.nodes)} nodes")

        # Get completed nodes from database
        completed_nodes = self.engine.get_completed_nodes(session_id, user_id)

        # Build execution plan
        execution_plan = self.engine.build_execution_plan(workflow, completed_nodes)
        logger.info(f"Built execution plan with {len(execution_plan)} waves for workflow {workflow_id}")

        # Link workflow to session at start of execution
        self.ryumem.update_session(
            session_id=session_id,
            user_id=user_id,
            workflow_id=workflow_id,
            status="active"
        )

        # Execute workflow
        node_results = []
        context = initial_variables.copy()

        for wave_num, wave in enumerate(execution_plan, 1):
            logger.info(f"ðŸŒŠ Executing wave {wave_num}/{len(execution_plan)}: {[n.node_id for n in wave]}")

            for node in wave:
                from ryumem.core.workflow_models import NodeType

                logger.info(f"   âš™ï¸  Executing node: {node.node_id} (type: {node.node_type})")

                # Handle LLM_TRIGGER - pause for agent decision
                if node.node_type == NodeType.LLM_TRIGGER:
                    prompt = self._substitute_variables(node.llm_prompt or "Continue", context)
                    logger.info(f"   â¸ï¸  Pausing for LLM_TRIGGER at node {node.node_id}")
                    logger.info(f"   ðŸ’¬ Prompt: {prompt[:100]}...")
                    return self._pause_workflow(workflow_id, session_id, user_id, node.node_id, "llm_trigger", prompt=prompt)

                # Handle USER_TRIGGER - pause for user input
                if node.node_type == NodeType.USER_TRIGGER:
                    prompt = self._substitute_variables(node.user_prompt or "Provide input", context)
                    logger.info(f"   â¸ï¸  Pausing for USER_TRIGGER at node {node.node_id}")
                    logger.info(f"   ðŸ’¬ Prompt: {prompt[:100]}...")
                    return self._pause_workflow(workflow_id, session_id, user_id, node.node_id, "user_trigger", prompt=prompt, extra_fields={"input_variable": node.user_input_variable})

                # Execute node with error handling
                try:
                    result = self._execute_node(node, context, tool_registry)
                    logger.info(f"   âœ“ Node {node.node_id} completed: {str(result.get('output', ''))[:100]}")
                except Exception as e:
                    logger.error(f"   âŒ Node {node.node_id} failed: {e}")
                    return self._pause_workflow(workflow_id, session_id, user_id, node.node_id, "error", error=str(e))

                # Store output and result
                context[node.node_id] = result["output"]
                node_results.append(result)
                self.engine.store_node_result(node.node_id, result, session_id, user_id)

        # Mark workflow as complete
        self.engine.mark_workflow_complete(
            workflow_id=workflow_id,
            session_id=session_id,
            user_id=user_id,
            success=True
        )

        logger.info(f"âœ… Workflow {workflow_id} completed successfully!")
        logger.info(f"   Executed {len(node_results)} nodes")
        logger.info(f"   Final context variables: {list(context.keys())}")

        result = {
            "workflow_id": workflow_id,
            "session_id": session_id,
            "status": "completed",
            "node_results": node_results,
            "final_context": context
        }
        logger.info(f"   Returning result with status: {result['status']}")
        return result

    def continue_workflow_execution(
        self,
        session_id: str,
        user_id: str,
        response: str,
        tool_registry: Optional[dict[str, Any]] = None
    ) -> dict[str, Any]:
        """Continue paused workflow with response."""
        from datetime import datetime

        logger.info(f"â–¶ï¸  Continuing workflow: session_id={session_id}, user_id={user_id}")
        logger.info(f"   Response: {response[:100]}...")

        # Get session and validate paused
        session = self.ryumem.get_session(session_id)
        if not session or session.get("status") != "paused":
            logger.error(f"âŒ Session {session_id} not paused (status: {session.get('status') if session else 'not found'})")
            raise ValueError(f"Session {session_id} not paused")

        # Get pause info
        workflow_id = session.get("workflow_id")
        pause_info = self.engine.get_pause_info(session_id, user_id)
        pause_reason = pause_info.get("pause_reason")
        paused_node_id = pause_info.get("paused_at_node")

        logger.info(f"   Workflow ID: {workflow_id}")
        logger.info(f"   Paused at node: {paused_node_id}")
        logger.info(f"   Pause reason: {pause_reason}")

        # Create result based on pause reason
        result = {
            "node_id": paused_node_id,
            "node_type": pause_reason.upper(),
            "status": "completed" if pause_reason != "error" else "skipped",
            "output": response if pause_reason != "error" else None,
            "error": pause_info.get("error_details") if pause_reason == "error" else None,
            "duration_ms": 0,
            "timestamp": datetime.utcnow().isoformat()
        }

        # Store result
        self.engine.store_node_result(paused_node_id, result, session_id, user_id)

        # Build context from completed nodes
        session_vars = session.get("session_variables", {})
        initial_vars = self._build_context_from_results(session_vars)

        # Continue execution
        return self.execute_workflow(workflow_id, session_id, user_id, initial_vars, tool_registry=tool_registry)

    def _build_context_from_results(self, session_variables: dict) -> dict:
        """Extract outputs from _node_results for variable substitution."""
        context = {k: v for k, v in session_variables.items() if not k.startswith("_")}
        node_results = session_variables.get("_node_results", {})
        for node_id, result in node_results.items():
            if result.get("status") == "completed":
                context[node_id] = result.get("output")
        return context
