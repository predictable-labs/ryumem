"""
Client-side workflow manager.

Handles workflow retrieval and coordination with WorkflowEngine.
Workflow generation happens in the user's google_adk flow, not here.
"""

import logging
from typing import Any, List, Optional

from ryumem.core.workflow_models import WorkflowDefinition
from ryumem.workflows.engine import WorkflowEngine

logger = logging.getLogger(__name__)


class WorkflowManager:
    """
    Client-side workflow manager.

    Responsibilities:
    - Search for existing workflows
    - Coordinate with WorkflowEngine for execution
    - Save workflows generated by google_adk
    """

    def __init__(self, ryumem_client: Any):
        """
        Initialize workflow manager.

        Args:
            ryumem_client: Ryumem SDK instance

        Raises:
            ValueError: If workflow mode is not enabled
        """
        self.ryumem = ryumem_client
        self.engine = WorkflowEngine(ryumem_client)

        # Check if workflow mode is enabled
        if not self.ryumem.config.workflow.workflow_mode_enabled:
            raise ValueError(
                "Workflow mode not enabled. Set RYUMEM_WORKFLOW_MODE_ENABLED=true"
            )

    def search_workflow(
        self, query: str, user_id: str
    ) -> Optional[WorkflowDefinition]:
        """
        Search for existing workflow matching the query.

        Args:
            query: User query
            user_id: User ID

        Returns:
            WorkflowDefinition if found, None if not found
        """
        threshold = self.ryumem.config.workflow.similarity_threshold

        logger.info(f"Searching for similar workflows for query: {query[:50]}...")
        similar_workflows = self.ryumem.search_workflows(
            query=query,
            user_id=user_id,
            threshold=threshold,
        )

        if similar_workflows:
            # Found similar workflow - reuse it
            workflow_dict = similar_workflows[0]
            workflow = WorkflowDefinition(**workflow_dict)
            logger.info(
                f"Found similar workflow: {workflow.name} (ID: {workflow.workflow_id})"
            )
            return workflow

        logger.info("No similar workflow found")
        return None

    def save_workflow(self, workflow: WorkflowDefinition) -> str:
        """
        Save a workflow generated by google_adk.

        Args:
            workflow: WorkflowDefinition to save

        Returns:
            Workflow ID

        Raises:
            Exception: If save fails
        """
        if not self.ryumem.config.workflow.auto_save_workflows:
            logger.info("Auto-save disabled, skipping workflow save")
            return workflow.workflow_id

        result = self.ryumem.create_workflow(workflow.model_dump())
        workflow_id = result.get("workflow_id")
        logger.info(f"Saved workflow to server: {workflow_id}")
        return workflow_id

    def get_workflow(self, workflow_id: str) -> Optional[WorkflowDefinition]:
        """
        Get a specific workflow by ID.

        Args:
            workflow_id: Workflow ID

        Returns:
            WorkflowDefinition if found, None otherwise
        """
        workflow_dict = self.ryumem.get_workflow(workflow_id)
        if workflow_dict:
            return WorkflowDefinition(**workflow_dict)
        return None

    def list_workflows(
        self, user_id: Optional[str] = None, limit: int = 100
    ) -> List[WorkflowDefinition]:
        """
        List workflows.

        Args:
            user_id: Filter by user ID (optional)
            limit: Maximum number of workflows to return

        Returns:
            List of WorkflowDefinitions
        """
        workflow_dicts = self.ryumem.list_workflows(user_id=user_id, limit=limit)
        return [WorkflowDefinition(**w) for w in workflow_dicts]

    def execute_workflow(
        self,
        workflow_id: str,
        session_id: str,
        user_id: str,
        initial_variables: dict[str, Any],
        tool_registry: Optional[dict[str, Any]] = None
    ) -> dict[str, Any]:
        """
        Execute a workflow client-side.

        Args:
            workflow_id: Workflow ID to execute
            session_id: Session ID for tracking execution
            user_id: User ID for session tracking
            initial_variables: Initial variables for workflow context
            tool_registry: Optional dictionary mapping tool names to callable functions

        Returns:
            Execution result with status and node outputs

        Raises:
            ValueError: If workflow not found
        """
        # Get workflow definition
        workflow = self.get_workflow(workflow_id)
        if not workflow:
            raise ValueError(f"Workflow {workflow_id} not found")

        # Build execution plan
        execution_plan = self.engine.build_execution_plan(workflow.nodes)
        logger.info(f"Built execution plan with {len(execution_plan)} waves for workflow {workflow_id}")

        # Execute workflow
        node_results = []
        context = initial_variables.copy()

        for wave_num, wave in enumerate(execution_plan, 1):
            logger.info(f"Executing wave {wave_num}/{len(execution_plan)}: {[n.node_id for n in wave]}")

            for node in wave:
                # TODO: Implement actual tool execution using tool_registry
                # For now, simulate execution
                result = {
                    "node_id": node.node_id,
                    "node_type": node.node_type,
                    "status": "completed",
                    "output": f"Simulated output for {node.node_id}",
                    "duration_ms": 100
                }

                # Store result in context for downstream nodes
                context[node.node_id] = result["output"]
                node_results.append(result)

                # Store result in session
                self.engine.store_node_result(
                    node_id=node.node_id,
                    result=result,
                    session_id=session_id,
                    user_id=user_id
                )

        # Mark workflow as complete
        self.engine.mark_workflow_complete(
            workflow_id=workflow_id,
            session_id=session_id,
            user_id=user_id,
            success=True
        )

        logger.info(f"Workflow {workflow_id} completed successfully with {len(node_results)} nodes")

        return {
            "workflow_id": workflow_id,
            "session_id": session_id,
            "status": "completed",
            "node_results": node_results,
            "final_context": context
        }
